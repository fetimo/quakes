// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package models

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjsonD2b7633eDecodeGitlabComLadyDascalieEarthquakesDbModels(in *jlexer.Lexer, out *GeoServe) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "cities":
			if in.IsNull() {
				in.Skip()
				out.Cities = nil
			} else {
				in.Delim('[')
				if out.Cities == nil {
					if !in.IsDelim(']') {
						out.Cities = make([]City, 0, 1)
					} else {
						out.Cities = []City{}
					}
				} else {
					out.Cities = (out.Cities)[:0]
				}
				for !in.IsDelim(']') {
					var v1 City
					(v1).UnmarshalEasyJSON(in)
					out.Cities = append(out.Cities, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "timezone":
			easyjsonD2b7633eDecode(in, &out.Timezone)
		case "region":
			easyjsonD2b7633eDecode1(in, &out.Region)
		case "fe":
			easyjsonD2b7633eDecode2(in, &out.Fe)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD2b7633eEncodeGitlabComLadyDascalieEarthquakesDbModels(out *jwriter.Writer, in GeoServe) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"cities\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Cities == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v2, v3 := range in.Cities {
				if v2 > 0 {
					out.RawByte(',')
				}
				(v3).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"timezone\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonD2b7633eEncode(out, in.Timezone)
	}
	{
		const prefix string = ",\"region\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonD2b7633eEncode1(out, in.Region)
	}
	{
		const prefix string = ",\"fe\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjsonD2b7633eEncode2(out, in.Fe)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v GeoServe) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonD2b7633eEncodeGitlabComLadyDascalieEarthquakesDbModels(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v GeoServe) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonD2b7633eEncodeGitlabComLadyDascalieEarthquakesDbModels(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *GeoServe) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD2b7633eDecodeGitlabComLadyDascalieEarthquakesDbModels(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *GeoServe) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD2b7633eDecodeGitlabComLadyDascalieEarthquakesDbModels(l, v)
}
func easyjsonD2b7633eDecode2(in *jlexer.Lexer, out *struct {
	Number      *int    `json:"number"`
	MediumName  *string `json:"mediumName"`
	HDS         *string `json:"hds"`
	SpanishName *string `json:"spanishName"`
	ShortName   *string `json:"shortName"`
	LongName    *string `json:"longName"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "number":
			if in.IsNull() {
				in.Skip()
				out.Number = nil
			} else {
				if out.Number == nil {
					out.Number = new(int)
				}
				*out.Number = int(in.Int())
			}
		case "mediumName":
			if in.IsNull() {
				in.Skip()
				out.MediumName = nil
			} else {
				if out.MediumName == nil {
					out.MediumName = new(string)
				}
				*out.MediumName = string(in.String())
			}
		case "hds":
			if in.IsNull() {
				in.Skip()
				out.HDS = nil
			} else {
				if out.HDS == nil {
					out.HDS = new(string)
				}
				*out.HDS = string(in.String())
			}
		case "spanishName":
			if in.IsNull() {
				in.Skip()
				out.SpanishName = nil
			} else {
				if out.SpanishName == nil {
					out.SpanishName = new(string)
				}
				*out.SpanishName = string(in.String())
			}
		case "shortName":
			if in.IsNull() {
				in.Skip()
				out.ShortName = nil
			} else {
				if out.ShortName == nil {
					out.ShortName = new(string)
				}
				*out.ShortName = string(in.String())
			}
		case "longName":
			if in.IsNull() {
				in.Skip()
				out.LongName = nil
			} else {
				if out.LongName == nil {
					out.LongName = new(string)
				}
				*out.LongName = string(in.String())
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD2b7633eEncode2(out *jwriter.Writer, in struct {
	Number      *int    `json:"number"`
	MediumName  *string `json:"mediumName"`
	HDS         *string `json:"hds"`
	SpanishName *string `json:"spanishName"`
	ShortName   *string `json:"shortName"`
	LongName    *string `json:"longName"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"number\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Number == nil {
			out.RawString("null")
		} else {
			out.Int(int(*in.Number))
		}
	}
	{
		const prefix string = ",\"mediumName\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.MediumName == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.MediumName))
		}
	}
	{
		const prefix string = ",\"hds\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.HDS == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.HDS))
		}
	}
	{
		const prefix string = ",\"spanishName\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.SpanishName == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.SpanishName))
		}
	}
	{
		const prefix string = ",\"shortName\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.ShortName == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.ShortName))
		}
	}
	{
		const prefix string = ",\"longName\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.LongName == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.LongName))
		}
	}
	out.RawByte('}')
}
func easyjsonD2b7633eDecode1(in *jlexer.Lexer, out *struct {
	Country *string `json:"country"`
	State   *string `json:"state"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "country":
			if in.IsNull() {
				in.Skip()
				out.Country = nil
			} else {
				if out.Country == nil {
					out.Country = new(string)
				}
				*out.Country = string(in.String())
			}
		case "state":
			if in.IsNull() {
				in.Skip()
				out.State = nil
			} else {
				if out.State == nil {
					out.State = new(string)
				}
				*out.State = string(in.String())
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD2b7633eEncode1(out *jwriter.Writer, in struct {
	Country *string `json:"country"`
	State   *string `json:"state"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"country\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Country == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.Country))
		}
	}
	{
		const prefix string = ",\"state\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.State == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.State))
		}
	}
	out.RawByte('}')
}
func easyjsonD2b7633eDecode(in *jlexer.Lexer, out *struct {
	UTCOffset *int     `json:"utcOffset"`
	Latitude  *float64 `json:"latitude"`
	UtcTime   *string  `json:"utcTime"`
	Time      *string  `json:"time"`
	ShortName *string  `json:"shortName"`
	Longitude *float64 `json:"longitude"`
	LongName  *string  `json:"longName"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "utcOffset":
			if in.IsNull() {
				in.Skip()
				out.UTCOffset = nil
			} else {
				if out.UTCOffset == nil {
					out.UTCOffset = new(int)
				}
				*out.UTCOffset = int(in.Int())
			}
		case "latitude":
			if in.IsNull() {
				in.Skip()
				out.Latitude = nil
			} else {
				if out.Latitude == nil {
					out.Latitude = new(float64)
				}
				*out.Latitude = float64(in.Float64())
			}
		case "utcTime":
			if in.IsNull() {
				in.Skip()
				out.UtcTime = nil
			} else {
				if out.UtcTime == nil {
					out.UtcTime = new(string)
				}
				*out.UtcTime = string(in.String())
			}
		case "time":
			if in.IsNull() {
				in.Skip()
				out.Time = nil
			} else {
				if out.Time == nil {
					out.Time = new(string)
				}
				*out.Time = string(in.String())
			}
		case "shortName":
			if in.IsNull() {
				in.Skip()
				out.ShortName = nil
			} else {
				if out.ShortName == nil {
					out.ShortName = new(string)
				}
				*out.ShortName = string(in.String())
			}
		case "longitude":
			if in.IsNull() {
				in.Skip()
				out.Longitude = nil
			} else {
				if out.Longitude == nil {
					out.Longitude = new(float64)
				}
				*out.Longitude = float64(in.Float64())
			}
		case "longName":
			if in.IsNull() {
				in.Skip()
				out.LongName = nil
			} else {
				if out.LongName == nil {
					out.LongName = new(string)
				}
				*out.LongName = string(in.String())
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD2b7633eEncode(out *jwriter.Writer, in struct {
	UTCOffset *int     `json:"utcOffset"`
	Latitude  *float64 `json:"latitude"`
	UtcTime   *string  `json:"utcTime"`
	Time      *string  `json:"time"`
	ShortName *string  `json:"shortName"`
	Longitude *float64 `json:"longitude"`
	LongName  *string  `json:"longName"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"utcOffset\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.UTCOffset == nil {
			out.RawString("null")
		} else {
			out.Int(int(*in.UTCOffset))
		}
	}
	{
		const prefix string = ",\"latitude\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Latitude == nil {
			out.RawString("null")
		} else {
			out.Float64(float64(*in.Latitude))
		}
	}
	{
		const prefix string = ",\"utcTime\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.UtcTime == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.UtcTime))
		}
	}
	{
		const prefix string = ",\"time\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Time == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.Time))
		}
	}
	{
		const prefix string = ",\"shortName\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.ShortName == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.ShortName))
		}
	}
	{
		const prefix string = ",\"longitude\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Longitude == nil {
			out.RawString("null")
		} else {
			out.Float64(float64(*in.Longitude))
		}
	}
	{
		const prefix string = ",\"longName\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.LongName == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.LongName))
		}
	}
	out.RawByte('}')
}
func easyjsonD2b7633eDecodeGitlabComLadyDascalieEarthquakesDbModels1(in *jlexer.Lexer, out *City) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "distance":
			if in.IsNull() {
				in.Skip()
				out.Distance = nil
			} else {
				if out.Distance == nil {
					out.Distance = new(int)
				}
				*out.Distance = int(in.Int())
			}
		case "longitude":
			if in.IsNull() {
				in.Skip()
				out.Longitude = nil
			} else {
				if out.Longitude == nil {
					out.Longitude = new(float64)
				}
				*out.Longitude = float64(in.Float64())
			}
		case "latitude":
			if in.IsNull() {
				in.Skip()
				out.Latitude = nil
			} else {
				if out.Latitude == nil {
					out.Latitude = new(float64)
				}
				*out.Latitude = float64(in.Float64())
			}
		case "name":
			if in.IsNull() {
				in.Skip()
				out.Name = nil
			} else {
				if out.Name == nil {
					out.Name = new(string)
				}
				*out.Name = string(in.String())
			}
		case "direction":
			if in.IsNull() {
				in.Skip()
				out.Direction = nil
			} else {
				if out.Direction == nil {
					out.Direction = new(string)
				}
				*out.Direction = string(in.String())
			}
		case "population":
			if in.IsNull() {
				in.Skip()
				out.Population = nil
			} else {
				if out.Population == nil {
					out.Population = new(int)
				}
				*out.Population = int(in.Int())
			}
		case "open_street_map":
			out.OpenStreetMapURL = string(in.String())
		case "apple_maps":
			out.AppleMapsURL = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD2b7633eEncodeGitlabComLadyDascalieEarthquakesDbModels1(out *jwriter.Writer, in City) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"distance\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Distance == nil {
			out.RawString("null")
		} else {
			out.Int(int(*in.Distance))
		}
	}
	{
		const prefix string = ",\"longitude\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Longitude == nil {
			out.RawString("null")
		} else {
			out.Float64(float64(*in.Longitude))
		}
	}
	{
		const prefix string = ",\"latitude\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Latitude == nil {
			out.RawString("null")
		} else {
			out.Float64(float64(*in.Latitude))
		}
	}
	{
		const prefix string = ",\"name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Name == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.Name))
		}
	}
	{
		const prefix string = ",\"direction\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Direction == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.Direction))
		}
	}
	{
		const prefix string = ",\"population\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Population == nil {
			out.RawString("null")
		} else {
			out.Int(int(*in.Population))
		}
	}
	{
		const prefix string = ",\"open_street_map\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.OpenStreetMapURL))
	}
	{
		const prefix string = ",\"apple_maps\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.AppleMapsURL))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v City) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonD2b7633eEncodeGitlabComLadyDascalieEarthquakesDbModels1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v City) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonD2b7633eEncodeGitlabComLadyDascalieEarthquakesDbModels1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *City) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD2b7633eDecodeGitlabComLadyDascalieEarthquakesDbModels1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *City) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD2b7633eDecodeGitlabComLadyDascalieEarthquakesDbModels1(l, v)
}
